// Code generated by mockery v2.14.0. DO NOT EDIT.

package httpmock

import (
	http "net/http"

	httpmock "go.nhat.io/httpmock"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// Expectation is an autogenerated mock type for the expectation type
type Expectation struct {
	mock.Mock
}

// After provides a mock function with given fields: d
func (_m *Expectation) After(d time.Duration) httpmock.Expectation {
	ret := _m.Called(d)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(time.Duration) httpmock.Expectation); ok {
		r0 = rf(d)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// Handle provides a mock function with given fields: _a0, _a1, _a2
func (_m *Expectation) Handle(_a0 http.ResponseWriter, _a1 *http.Request, _a2 map[string]string) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(http.ResponseWriter, *http.Request, map[string]string) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Once provides a mock function with given fields:
func (_m *Expectation) Once() httpmock.Expectation {
	ret := _m.Called()

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func() httpmock.Expectation); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// Return provides a mock function with given fields: v
func (_m *Expectation) Return(v interface{}) httpmock.Expectation {
	ret := _m.Called(v)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(interface{}) httpmock.Expectation); ok {
		r0 = rf(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// ReturnCode provides a mock function with given fields: code
func (_m *Expectation) ReturnCode(code int) httpmock.Expectation {
	ret := _m.Called(code)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(int) httpmock.Expectation); ok {
		r0 = rf(code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// ReturnFile provides a mock function with given fields: filePath
func (_m *Expectation) ReturnFile(filePath string) httpmock.Expectation {
	ret := _m.Called(filePath)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(string) httpmock.Expectation); ok {
		r0 = rf(filePath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// ReturnHeader provides a mock function with given fields: header, value
func (_m *Expectation) ReturnHeader(header string, value string) httpmock.Expectation {
	ret := _m.Called(header, value)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(string, string) httpmock.Expectation); ok {
		r0 = rf(header, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// ReturnHeaders provides a mock function with given fields: headers
func (_m *Expectation) ReturnHeaders(headers map[string]string) httpmock.Expectation {
	ret := _m.Called(headers)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(map[string]string) httpmock.Expectation); ok {
		r0 = rf(headers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// ReturnJSON provides a mock function with given fields: body
func (_m *Expectation) ReturnJSON(body interface{}) httpmock.Expectation {
	ret := _m.Called(body)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(interface{}) httpmock.Expectation); ok {
		r0 = rf(body)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// Returnf provides a mock function with given fields: format, args
func (_m *Expectation) Returnf(format string, args ...interface{}) httpmock.Expectation {
	var _ca []interface{}
	_ca = append(_ca, format)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(string, ...interface{}) httpmock.Expectation); ok {
		r0 = rf(format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// Run provides a mock function with given fields: handle
func (_m *Expectation) Run(handle func(*http.Request) ([]byte, error)) httpmock.Expectation {
	ret := _m.Called(handle)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(func(*http.Request) ([]byte, error)) httpmock.Expectation); ok {
		r0 = rf(handle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// Times provides a mock function with given fields: i
func (_m *Expectation) Times(i uint) httpmock.Expectation {
	ret := _m.Called(i)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(uint) httpmock.Expectation); ok {
		r0 = rf(i)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// Twice provides a mock function with given fields:
func (_m *Expectation) Twice() httpmock.Expectation {
	ret := _m.Called()

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func() httpmock.Expectation); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// UnlimitedTimes provides a mock function with given fields:
func (_m *Expectation) UnlimitedTimes() httpmock.Expectation {
	ret := _m.Called()

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func() httpmock.Expectation); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// WaitUntil provides a mock function with given fields: w
func (_m *Expectation) WaitUntil(w <-chan time.Time) httpmock.Expectation {
	ret := _m.Called(w)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(<-chan time.Time) httpmock.Expectation); ok {
		r0 = rf(w)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// WithBody provides a mock function with given fields: body
func (_m *Expectation) WithBody(body interface{}) httpmock.Expectation {
	ret := _m.Called(body)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(interface{}) httpmock.Expectation); ok {
		r0 = rf(body)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// WithBodyJSON provides a mock function with given fields: v
func (_m *Expectation) WithBodyJSON(v interface{}) httpmock.Expectation {
	ret := _m.Called(v)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(interface{}) httpmock.Expectation); ok {
		r0 = rf(v)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// WithBodyf provides a mock function with given fields: format, args
func (_m *Expectation) WithBodyf(format string, args ...interface{}) httpmock.Expectation {
	var _ca []interface{}
	_ca = append(_ca, format)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(string, ...interface{}) httpmock.Expectation); ok {
		r0 = rf(format, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// WithHeader provides a mock function with given fields: header, value
func (_m *Expectation) WithHeader(header string, value interface{}) httpmock.Expectation {
	ret := _m.Called(header, value)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(string, interface{}) httpmock.Expectation); ok {
		r0 = rf(header, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

// WithHeaders provides a mock function with given fields: headers
func (_m *Expectation) WithHeaders(headers map[string]interface{}) httpmock.Expectation {
	ret := _m.Called(headers)

	var r0 httpmock.Expectation
	if rf, ok := ret.Get(0).(func(map[string]interface{}) httpmock.Expectation); ok {
		r0 = rf(headers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(httpmock.Expectation)
		}
	}

	return r0
}

type mockConstructorTestingTNewExpectation interface {
	mock.TestingT
	Cleanup(func())
}

// NewExpectation creates a new instance of Expectation. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewExpectation(t mockConstructorTestingTNewExpectation) *Expectation {
	mock := &Expectation{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
